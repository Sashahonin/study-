program optimal;
{
 1. Создаем масив из 6 чисел(окно)
 2. Заполняем его
 3. сравниваем первый элемент массива a[1] c минимальный найденым элементом
 4. если число четное сравниваем первый ЧЕТНЫЙ элемент массива a[1] c минимальный найденым элементом
 5. если x - четный  то умножаем его на минимальный элемент или если х- нечетный умножаем его на минимальный четный элемент
 6. В конце цикла сравниваем это число с минимальным произведением minP
 7. смещаем "окно" то есть 1 элемент принимает значение 2 и так далее, а последний принемает значение х
 7. выводим minP
 }
 const
   s = 6; //отступ
 var
   N, i, j, x : longint;
   min: longint;  //минимальный элемент
   min2: longint; //минимальный четный элемент
   mp: longint;   //наименьший найденый элемент в программе
   p: longint;    //наименьший элемент найденый в цикле за один проход
a: array[1..s] of longint;
begin
readln(N);
for i:=1 to s do
  readln(a[i]);
min := 1001;
min2 := 1001;
mp :=1001*1001;
for i := s + 1 to N do
begin
  readln(x);
  if a[1] < min then
    min := a[1];
  if (a[1] mod 2 = 0) and (a[1] < min2) then
    min2 := a[1];
  if x mod 2 = 0 then
    p := x * min
  else
    if min2 < 1001 then
      p := x * min2
    else
      p := 1001* 1001;
  if (p < mp) then
    mp := p;
  for j := 1 to s - 1 do
    a[j] := a[j + 1];
  a[s] := x
end;
if mp = 1001*1001 then
  mp:=-1;
writeln(mp)
end.

